--PL/SQL (Procedural Language edtension to SQL : sql을 확장한 절차적 언어)
--:관계형 데이터베이스에서 사용되는 오라클 엑세스 언어
--:PL/SQL블록을 보내면 서버쪽에서 블록을 받아 PROCEDURAL을 나눈다.
--:프로그램 종류 : procedure, function, trigger


--저장 프로시저(Stored Prodecure)
--:프로그래머가 생성해 놓은 쿼리문을 
--마치 하나의 메소드 형식으로 관리하는 것
--=>서버에 저장해놓고 주기적으로 반복해서 사용

--OR REPLACE: 이미 같은 이름의 프로시저가 
--	    존재하는 경우 기존의 프로시저 내용을
--	    지우고 새로운 내용으로 바꿔준다.



--
SET SERVEROUTPUT ON;
BEGIN 
DBMS_OUTPUT.PUT_LINE('Hello PL/SQL!');
END;
/

--
SET SERVEROUTPUT ON;
--V_CON이라는 변수를 하나 만들어 1을 대입함
DECLARE
    V_CON NUMBER:=1;    
BEGIN
    IF V_CON>1 THEN
        DBMS_OUTPUT.PUT_LINE('1초과');
    ELSIF V_CON <1 THEN
        DBMS_OUTPUT.PUT_LINE('1보다작다');
    ELSIF V_CON =1 THEN
        DBMS_OUTPUT.PUT_LINE('같다');
    
    END IF;
    END;
/

--
DECLARE
    V_SCORE NUMBER:=87;
    
BEGIN
    CASE
        WHEN V_SCORE>=90 THEN DBMS_OUTPUT.PUT_LINE('A');
        WHEN V_SCORE<90 THEN DBMS_OUTPUT.PUT_LINE('B');
    END CASE;
END;
/

--기본 LOOP
DECLARE
    V_CNT NUMBER:=0;
    V_SUM NUMBER:=0;

BEGIN
    LOOP
        V_CNT:=V_CNT+1;
        V_SUM:=V_SUM+V_CNT;
        DBMS_OUTPUT.PUT_LINE(V_SUM);
        EXIT WHEN V_CNT=10;
    END LOOP;
END;
/

--
DECLARE 
    V_CNT NUMBER:=0;
    V_SUM NUMBER:=0;
   BEGIN
    WHILE V_CNT <10 LOOP
    V_CNT:=V_CNT+1;
    V_SUM:=V_SUM+V_CNT;
     DBMS_OUTPUT.PUT_LINE('V_SUM :'||V_SUM);
    END LOOP;
   END;
/

--
DECLARE
    V_SUM NUMBER:=0;
    BEGIN
    FOR I IN 0..10 LOOP
    V_SUM:=V_SUM+I;
    DBMS_OUTPUT.PUT_LINE('V_SUM :'||V_SUM);
    END LOOP;
END;
/

--
SET SERVEROUTPUT ON;
BEGIN
FOR I IN 0..10 LOOP
CONTINUE WHEN MOD(I,2)=0;
DBMS_OUTPUT.PUT_LINE('현재 I의 값 : '||I);
END LOOP;
END;
/

--
DESC STUDENT;


CREATE OR REPLACE PROCEDURE TEST2
(V_STU_NO IN STUDENT.STU_NO%TYPE,
V_STU_GRADE IN STUDENT.STU_GRADE%TYPE)

IS
BEGIN
    UPDATE STUDENT
    SET STU_GRADE=V_STU_GRADE
    WHERE STU_NO=V_STU_NO;
    
END TEST2;
/

EXECUTE TEST2(20153075,3);

SELECT * FROM STUDENT;

--
CREATE OR REPLACE PROCEDURE TEST3
(V_STU_NO IN STUDENT.STU_NO%TYPE,
V_STU_NAME OUT STUDENT.STU_NAME%TYPE)
IS
BEGIN
    SELECT STU_NAME
    INTO V_STU_NAME --STU_NAME을 V_STU_NAME넣겠다.
    FROM STUDENT
    WHERE STU_NO=V_STU_NO;
    END TEST3;
/   
--이름을 전달받아야함(변수 정의)
VARIABLE D_STU_NAME VARCHAR2(10);
EXECUTE TEST3(20153075,:D_STU_NAME);
    
PRINT D_STU_NAME;

--
CREATE PROCEDURE TEST4
(V_SUB_NO IN ENROL.SUB_NO%TYPE,
V_STU_NO IN ENROL.STU_NO%TYPE,
V_ENR_GRADE IN OUT ENROL.ENR_GRADE%TYPE)

IS 
BEGIN
    UPDATE ENROL
    SET ENR_GRADE=ENR_GRADE+V_ENR_GRADE
    WHERE STU_NO=V_STU_NO AND SUB_NO=V_SUB_NO;
    END TEST4;
/

VARIABLE D_ENR_GRADE NUMBER
BEGIN
    :D_ENR_GRADE:=10;
    END;
    /
    
EXECUTE TEST4(101,20131001,:D_ENR_GRADE);
PRINT D_ENR_GRADE;

SELECT * FROM ENROL;


SELECT * FROM EMP;
--
--신입사원을 채용하였다.
--사원번호, 사원이름, 사원직무, 상급자사원번호, 급여, 부서번호를 입력받아
--사원 테이블에 삽입하는 프로시저를 작성해라.
CREATE OR REPLACE PROCEDURE TEST5
(V_EMPNO IN emp.empno%TYPE,
V_ENAME IN emp.ename%TYPE,
V_JOB IN emp.job%TYPE,
V_MGR IN emp.mgr%TYPE,
V_SAL IN emp.sal%TYPE,
V_DEPTNO IN emp.deptno%TYPE)
IS
BEGIN
INSERT INTO EMP(EMPNO,ENAME,JOB,MGR,SAL,DEPTNO)
VALUES(V_EMPNO,V_ENAME,V_JOB ,V_MGR,V_SAL, V_DEPTNO);

COMMIT;
END TEST5;
/

EXECUTE NEWEMPLOYEE(7888,'히히히','대리',7832,7000,20);

SELECT *FROM EMP;


--부서번호를 변경하는 프로시저를 작성해라.
--(emp 테이블에서) - update~set~where
--(입력된 사원번호가 같을때 부서번호 
--변경해라)

CREATE OR REPLACE PROCEDURE TEST6(
V_EMPNO IN EMP.EMPNO%TYPE,
V_DEPTNO IN EMP.DEPTNO%TYPE)
IS
BEGIN
UPDATE EMP
SET DEPTNO=V_DEPTNO
WHERE EMPNO=V_EMPNO;

COMMIT;
END TEST6;
/

EXECUTE TEST6(7888,10);
SELECT*FROM EMP;

--
CREATE SEQUENCE SEQ1
INCREMENT BY 1
START WITH 201
MAXVALUE 999;

SELECT * FROM USER_SEQUENCES;

SELECT SEQ1.NEXTVAL FROM DUAL;

create or replace procedure test5(
V_SUB_NAME IN SUBJECT.SUB_NAME%TYPE,
V_SUB_PROF IN SUBJECT.SUB_PROF%TYPE,
V_SUB_GRADE IN SUBJECT.SUB_GRADE%TYPE,
V_SUB_DEPT IN SUBJECT.SUB_DEPT%TYPE)
IS
BEGIN
    INSERT INTO SUBJECT VALUES(SEQ1.NEXTVAL,V_SUB_NAME,V_SUB_PROF,V_SUB_GRADE,V_SUB_DEPT);
    COMMIT;
    END TEST5;
/
EXECUTE TEST5('PL/SQL','홍길동',3,'컴퓨터정보');
SELECT * FROM SUBJECT;

DROP SEQUENCE SEQ1;

CREATE TABLE CUST(
C_NO NUMBER(3) NOT NULL,
C_NAME VARCHAR2(10),
C_FLAG NUMBER(1),
C_ADDR VARCHAR2(20),
C_PHONE VARCHAR2(20),
CONSTRAINT C_NO_PK PRIMARY KEY(C_NO));

insert into cust values(101,'김진수',1,'서울 성북구','02-455-5544');
insert into cust values(102,'김영희',2,'서울 강서구','02-299-2565');
insert into cust values(103,'이영수',3,'서울 서초구','02-555-5555');
insert into cust values(104,'김진숙',1,'서울 동대문구','02-444-4444');

CREATE TABLE VIDEO(
V_NO NUMBER(1) NOT NULL,
CONSTRAINT PK_V_NO PRIMARY KEY(V_NO),
V_NAME VARCHAR2(20),
V_ACTOR VARCHAR2(20),
V_GROUP VARCHAR2(20));

insert into video values(1,'극한직업','류승룡 이하늬','코미디');
insert into video values(2,'기생충','송강호','드라마');
insert into video values(3,'엑시트','조정석 윤아','코미디');
insert into video values(4,'봉오동전투','유해진','액션');
insert into video values(5,'나쁜녀석들','마동석','액션');
insert into video values(6,'82년생김지영','정유미 공유','드라마');

CREATE TABLE RENT(
R_NO NUMBER(1) CONSTRAINT PK_RENT PRIMARY KEY,
R_DATE DATE,
C_NO NUMBER(3) CONSTRAINT C_NO_FK REFERENCES CUST(C_NO),--부모:CUST, 자식:RENT
R_RENTFEE NUMBER(5),
V_NO NUMBER(1) CONSTRAINT V_NO_FK REFERENCES VIDEO(V_NO));


insert into rent values(1,'2020-07-30',101,1000,1);
insert into rent values(2,'2020-07-30',101,500,2);
insert into rent values(3,'2020-08-2',103,500,5);
insert into rent values(4,'2020-08-2',102,1000,6);
insert into rent values(5,'2020-08-2',102,1000,3);
insert into rent values(6,'2020-08-3',104,2000,2);


--고객 테이블의 구조를 검색해라. (3점)
DESC CUST;
--고객 테이블의 고객이름, 등급, 주소를 검색해라. (3점)
SELECT C_NAME,C_FLAG,C_ADDR FROM CUST;
--비디오이름과 고객번호, 반납일을 equi join, natural join, join~using을 다 써서 검색해라. (10점)
--EQUI JOIN
SELECT V_NAME, C_NO, R_DATE
FROM VIDEO,RENT
WHERE VIDEO.V_NO=RENT.V_NO;
--NATURAL JOIN
SELECT V_NAME,C_NO,R_DATE
FROM VIDEO NATURAL JOIN RENT;
--JOIN~USING
SELECT V_NAME,C_NO,R_DATE
FROM VIDEO JOIN RENT USING(V_NO);
--이영수 고객이 대여한 비디오이름과 주연배우를 검색해라. (equi join) (3점)
SELECT V_NAME,V_ACTOR
FROM VIDEO,RENT,CUST
WHERE VIDEO.V_NO=RENT.V_NO AND RENT.C_NO=CUST.C_NO AND C_NAME='이영수';
--기생충을 대여한 고객들의 고객번호와 이름을 검색해라. (3점)
SELECT CUST.C_NO,C_NAME
FROM CUST, RENT, VIDEO
WHERE CUST.C_NO=RENT.C_NO AND RENT.V_NO=VIDEO.V_NO AND V_NAME='기생충';
--등급이 1등급인 고객이 대여한 비디오 이름을 모두 검색해라. (3점)
SELECT V_NAME
FROM VIDEO, RENT,CUST
WHERE CUST.C_NO=RENT.C_NO AND VIDEO.V_NO=RENT.V_NO AND C_FLAG=1;
--대여료가 2000원 이상인 고객의 수를 검색해라. (3점)
--1명 출력
SELECT COUNT(C_NO)
FROM RENT
WHERE R_RENTFEE>=2000;
--총대여료로 계산해서 2명 출력
SELECT COUNT(*)
FROM (SELECT C_NO
FROM RENT GROUP BY C_NO
HAVING SUM(R_RENTFEE)>=2000);
